<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>原型模式</title>
</head>
<body>
<script>

    //构造函数解决了实例私有属性问题
    //原型模式解决了属性的公有问题:
    //原型模式:
    //1.每一个函数数据类型(函数/类)都天生自带一个prototype属性,prototype的属性值是一个对象数据类型的.
    //2.prototype 属性中天生自带一个constructor属性,属性值是当前原型所属的类.
    //3.每一个对象数据类型值(对象,arguments,数组)天生自带一个__proto__属性,属性值指向当前实例所属类的原型.

    //数组类,Array 内置的类

    //当获取对象的属性名对应的属性值时,首先会看是否是私有属性,如果不是,那么会通过__proto__属性继续向上查找,如果上一级原型中也不存在,那么会通过原型中__proto__继续向上查找,直到找到Object的原型为止,如果也没有,那么会输出undefined,这样一级级向上查找就会形成一个"原型链"

    //共有属性,所有的实例都可以使用公有属性中的方法.

    //内置类  Number String Boolean Null Undefined Object Array RegExp Date Function

    function Fn(num) {
        this.a=1;
        this.b=2;

    }
    var f =new Fn(1);
    console.log(Fn.prototype.constructor===Fn);//true
    console.log(f.__proto__ === Fn.prototype);
    console.log(f);
    console.log(f.constructor);
    console.dir(Fn);


    // function Fn(name) {
    //     this.a = name;
    //     this.b = 10;
    //     // this.eat = function () {
    //     //     console.log("person");
    //     // }
    // }
    // Fn.prototype.eat=function () {
    //     console.log("person");
    // }
    //
    //
    // var f = new Fn("deng");
    // console.log(f);
    // var f1 = new Fn("he");
    // console.log(f1);
    // console.log(f.a === f1.a);
    // console.log(f.b === f1.b);
    // console.log(f.eat === f1.eat);
    //构造函数解决了实例私有属性问题.
    // console.log(f.eat());


</script>
</body>
</html>