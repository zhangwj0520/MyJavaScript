<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>构造函数模式</title>
</head>
<body>
<script>
    // function Fn() {
    //     console.log(1);
    //     this.name="hah";
    //     this.age=10;
    //
    // }
    // console.log(new Fn());
    // console.log(new Fn);   //new 是关键字,放在函数的前面;函数就变成一个构造函数

    //构造函数被new,那么就会创建出一个实例;

    //普通函数和构造函数的区别:

    //普通函数.形成私有的作用域--->形参赋值--->变量提升--->代码从上到下运行-->作用域销毁;

    //不同点:  1构造函数运行时,形成作用域之后,在代码运行之前,首先会给当前作用域初始化一个对象,并且让当前作用域下的this指向当前这个空对象.  执行空对象中的代码   --->返回新对象(this)
    //2.构造函数如果不需要参数,可以省略执行的小括号;
    //3.构造函数中的this,指向当前的实例.
    //4.在构造函数中 return一个基本数据类型值,那么对实例没有任何影响,如果return引用数据类型值,那么会把默认的return替换掉.
    //5.instanceof  检测当前实例是否属于某个类的,如果属于 返回true,不属于返回false
    //6.in :检测属性是否属于对象的,是--true  ,否----false;
    //7.hasOwnProperty;检测是否是私有属性的;


    //构造函数就是一个自定义的类.


    function Person(name, age, job) {
        //return 10; //可以终止代码
        this.name=name;
        this.age=age;
        this.job=job;
        this.sayName=function () {
            alert(this.name);
        }
    }
    var person1=new Person("a",10,"doctor");
    var person2=new Person("b",22,"techer");
    console.log(person1);
    console.log(person2);

    // function Fn(num) {
    //     this.a=10;
    //     this.b="hahh";
    // }
    // var f=new Fn;
    // var f1=new Fn;
    // console.log(f instanceof Fn);
    // console.log(f instanceof Object);
    // console.log(f);
    // console.log(f1);
    // console.log(f === f1);
    // console.log(f.hasOwnProperty("a"));
    // console.log(f.hasOwnProperty("toString"));//
    //
    //
    // var obj1={a:10,b:"hahh"};
    // console.log(obj1);
    // console.log("toString" in obj1);
    // var obj={};
    // console.log(obj1.toString === obj.toString);//共有属性.


    //如果是共有属性返回true,如果不是返回false;
    // function hasPublicProperty(obj,attr) {
    //     if(attr in obj){
    //         if(obj.hasOwnProperty(attr)){
    //             return false;
    //         }
    //         else{
    //             return true;
    //         }
    //     }
    //         return false;
    //    // return attr in obj &&!obj.hasOwnProperty(attr)?true:false;
    //
    //
    // }
    // var obj={a:22,b:"haha"};
    // console.log(hasPublicProperty(obj, "toString"));


</script>

</body>
</html>